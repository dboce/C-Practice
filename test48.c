#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
#include <string.h>
#include <math.h>
/// 函数递归1
/*
什么是递归?
    程序调用自身的编程技巧称为递归(recursion).
    递归做为一种算法在程序设计语言中广泛应用.
    一个过程或函数在其定义或说明中直接或间接调用自身的一种方法, 它通常把一个大型复杂的问题层层转换为一个
    递归的主要思考方式在于: 把大事化小

递归的两个必要条件:
    存在限制条件, 当满足这个限制条件的时候, 递归便不再继续.
    每次递归之后越来越接近这个限制条件.
*/

void print(unsigned int n)
{
    if (n > 9) // 满足条件才递归
    {
        print(n / 10); // 让递归越来越逼近条件
    }
    printf("%d ", n % 10);
}

void test(int n)
{
    if (n < 10000)
    {
        test(n + 1);
    }
}

int main()
{
    // printf("hehe\n");
    // main(); // 自己调自己叫递归

    // 练习一:接受一个整型值(无符号),按照顺序打印它的每一位. 例如:输入: 1234 ,输出: 1 2 3 4
    // print(1234)
    // print(123) 4
    // print(12) 3 4
    // print(1) 2 3 4
    unsigned int num = 0; // 无符号整型
    scanf("%u", &num);    // 1234
    // 递归-函数自己调用自己
    print(num); // print函数可以打印参数部分数字的每一位

    // 练习二: 递归-栈溢出的情况
    test(1); // 报错:栈溢出
    /*内存分区
    栈区
        局部变量
        函数形参
        调用函数时返回值等临时变量
    堆区
        动态内存分配的
            malloc/free
            calloc
            realloc
    静态区
        全局变量
        静态变量
    */
    // 每一次函数调用都要在栈区分配空间
    // 递归层次太深,栈空间内存耗尽了, 就栈溢出了
    /*写递归代码的时候要注意:
    1. 不能死递归, 都有跳出条件, 每次递归逼近跳出条件
    2. 递归层次不能太深
    */

    // www.stackoverflow.com 程序员的知乎!
    // 英文提问, 英文回答

    return 0;
}
