#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
#include <string.h>
/// 算数转换练习

// NumberOf1就是计算参数n的二进制补码中有几个1
/*思路:
   123
   123%10 = 3
   123/10 = 12
   12%10 = 2
   12/10 = 1
   1%10 = 1
   1/10 = 0

   15 - 000011111
   15%2 = 1
   15/2 = 7 -- 00000111
   7%2 = 1
   7/2 = 3 -- 00000011
   3%2 = 1
   3/2 = 1 -- 00000001
   1%2 = 1
   1/2 = 0 -- 00000000

   14 - 00001110
   14%2 = 0
   14/2 = 7 -- 00000111
*/
// 方法一: 对于正数可以, 对于负数不行
int NumberOf1(int n)
{
    int count = 0;
    while (n) // 如果n不是0
    {
        if (n % 2 == 1)
        {
            count++;
        }
        n /= 2;
    }
    return count;
}
// 方法二: 通过和1进行按位与操作,来判断个数
int NumberOf1(int n)
{
    int count = 0;
    int i = 0;
    for (i = 0; i < 32; i++)
    {
        if (((n >> i) & 1) == 1) // 通过和1进行按位与操作,来判断个数
        {
            count++;
        }
    }

    return count;
}

// 方法三:
/*分析 n = n&(n-1) // 每次n&(n-1) 会去掉一个1
n = 15
1111 - n
1110 - n-1
1110 - n
1101 - n-1
1100 - n
1011 - n-1
1000 - n
0111 - n-1
0000 - n
*/
int NumberOf1(int n)
{
    int count = 0;
    int i = 0;
    while (n)
    {
        n = n & (n - 1);
        count++;
    }
    return count;
}

int main(int argc, char const *argv[])
{
    // 练习一:
    int a, b, c;
    a = 5;
    c = ++a;                                    // c=6 a=6
    b = ++c, c++, ++a, a++;                     // c=8 a=8 b=7
    b += a++ + c;                               // b=21 a=8
    printf("a = %d b = %d c = %d\n:", a, b, c); // a=9 b=23 c=8

    // 练习二: 统计二进制中的个数
    // 写一个函数返回参数二进制中1的个数
    // 比如: 15  00001111    4个1
    // 牛客网:输入一个整数,输出该数32位进制表示中1的个数,其中负数用补码表示.
    int n = 10;
    int ret = NumberOf1(n);
    printf("ret = %d\n", ret);

    // 练习三: 写一个代码判断一个数字是不是2的n次方
    // 规律: 2的n次方的数字, 它的二进制数里只有一个1
    // 也就是: k&(k-1) == 0

    // 练习四: 求两个数二进制中不同位的个数
    // 编程实现:两个int(32位)整数m和n的二进制表达式中,有多个位(bit)不同?
    // 输入例子: 22 33
    // 输出例子: 5
    int m = 0;
    int n = 0;
    int i = 0;
    int count = 0;
    scanf("%d %d", &m, &n);
    // 方法一:
    for (i = 0; i < 32; i++)
    {
        if (((m >> i) & 1) != ((n >> i) & 1))
        {
            count++;
        }
        printf("%d\n", count);
    }
    // 方法二:
    int ret = m ^ n; // 相同为0, 相异为1
    // 统计一下ret的二进制中有几个1, 就说明m和n的二进制中有几个位不同
    count = NumberOf1(ret);
    printf("%d\n", count);

    // 练习四: 打印二进制的基数和偶数位
    // 获取一个整数的二进制序列中所有的偶数位和奇数位, 分别打印出二进制序列
    // 00000000000000000000000000000001
    int i = 0;
    // 打印偶数位
    for (i = 31; i >= 1; i -= 2)
    {
        printf("%d ", (n >> i) & 1);
    }
    printf("\n");
    // 打印奇数位
    for (i = 30; i >= 0; i -= 2)
    {
        printf("%d ", (n >> i) & 1);
    }

    // 练习五:交换两个变量(不创建临时变量)
    // 不允许创建临时变量, 交换两个整数的内容
    int a = 10;
    int b = 20;
    a = a ^ b;
    b = a ^ b; // a^b^b = a
    a = a ^ b; // a^b^a = b
    printf("a=%d b=%d\n", a, b);

    // 练习六:
    /*下面代码的运行结果:
    int i = 1;
    int ret = (++i) + (++i) + (++i);
    printf("ret = %d\n", ret);
    答:程序错误, 因为无法分辨出它先执行哪个运算
    */

    // 练习七
    /*以下系统中, int类型占几个字节, 指针占几个字节, 操作系统可以使用的最大内存空间是多大?
    答: 32位以下: 4,4,2^32  64位: 4,8,2^64

    // 整型的大小不管在什么平台上都是4个字节;
    // 指针的大小在32位平台4个字节, 在64位平台上8个字节, 因为地址线是不同的
    */

    // 练习八: 输出结果
    /*
    10进制: 1
    二进制: 00000000 00000000 00000000 00000001
    16进制: 00 00 00 01

    小端存储
    arr
    01 00 00 00 02 00 00 00 03 00 00 00 04 00 00 00 05 00 00 00

    short占2个字节
    short+1跳两个字节
    */
    int arr[] = {1, 2, 3, 4, 5};
    short *p = (short *)arr;
    int i = 0;
    for (i = 0; i < 4; i++)
    {
        *(p + i) = 0; // 修改内容
    }
    for (i = 0; i < 5; i++)
    {
        printf("%d ", arr[i]); // 0 0 3 4 5
    }

    return 0;
}
