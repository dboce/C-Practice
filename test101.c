#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
#include <string.h>
#include <limits.h> //定义整型家族的变量类型的取值范围
#include <float.h>  //定义浮点家族的变量类型的取值范围
/// 浮点型的存储
/*浮点型在内存中的存储:
常见的浮点数:
    3.1415 1E10 浮点数家族包括: `float double long double`类型.
    浮点数表示的范围: float.h中定义
*/

int main(int argc, char const *argv[])
{
    /*浮点数和整数在内存中存储的方式一定是有区别的!
    根据国际标准IEEE(电气和电子工程协会) 754, 任意一个二进制浮点数V可以表示成下面的形式:
        (-1)^S * M * 2^E
        (-1)^S表示符号位, 当S=0时, V为正数; 当S=1, V为负数.
        M表示有效数字, 大于等于1, 小于2.
        2^E表示指数位
    举例来说: 十进制的5.0, 写成二进制是101.0, 相当于1.01*2^2,
    那么按照上面V的格式,可以得出s=0, M=1.01, E=2
    十进制的-5.0, 写成二进制是-101.0, 相当于-1.01*2^2,那么s=1, M=1.01, E=2

    IEEE 754规定: 对于32位浮点数, 最高的1位是符号位s, 接着的8位是指数E, 剩下的23位有效数字M.

    float单精度浮点数存储模型:
    0        00000000 00000000000000000000000
    S(1bit)  E(8bit)    M(23bit)

    double双精度浮点数存储模型:
    0        00000000000 00000000000000000000
    S(1bit)  E(11bit)        M(52bit)

    `IEEE 754对有效数字M和指数E, 还有一些特别规定.` 前面说过, 1<=M<2, 也就是说M可以写成1.xxxxxx的形式,其中xxxxxx表示小数部分.

    IEEE 754规定, 在计算机内部保存M时, 默认这个数的第一位总是1, 因此可以被舍去, 只保存后面的xxxxxx部分.
    比如保存1.01的时候, 只保存01, 等到读取的时候, 再把第一位的1加上去. 这样做的目的是节省1位有效数字.
    以32位浮点数为例, 留给M只有32为, 将第一位的1舍去以后, 等于可以保存24位有效数字.

    `至于指数E, 情况比较复杂.`
    `首先, E为一个无符号整数(unsigned int)` 这意味着, 如果E为8位, 它的取值范围为0~255; 如果E为11位, 它的取值范围为0~2047.
    但是, 我们知道,科学计数法中的E是可以出现负数的, 所以IEEE 754规定, 存入内存时E的真实值必须再加上一个中间数,
    对于8位的E,这个中间数是127; 对于11位的E, 这个中间数是1023.
    比如, 2^10的E是10, 所以保存成32位浮点数时, 必须保存成10+127=137, 即10001001

    然后, 指数E从内存中取出还可以再分成三种情况:
        `E不全为0或不全为1`
            这时,浮点数就采用下面的规则表示, 即指数E的计算值减去127(或1023), 得到真实值, 再将有效数字M前加上第一位的1.
            比如: 0.5(1/2)的二进制形式为0.1, 由于规定正数必须为1, 即将小数点右移1位,
            则为1.0*2^(-1), 其阶码为-1+127=126, 表示为01111110, 而尾数1.0去掉整数部分为0, 补齐0到23位,
            则其二进制表示形式为 `0 01111110 00000000000000000000000`
        `E全为0`
            这时, 浮点数的指数E等于1-127(或者1-1023)即为真实值, 有效数字M不再加上第一位的1, 而是还原为0.xxxxxx的小数.
            这样做为了表示±0, 以及接近于0的很小的数字.
        `E全为1`
            这时,如果有效数字M全为0, 表示±无穷大(正负取决于符号位s)
    */

    float f = 5.5f;
    /*5.5
        十进制: 5.5
        二进制: 101.1 //.后面表示2的负几次方
        二进制科学计数法: 1.011 * 2^2 //因为是二进制数所以乘以2的2次方
        转换: (-1)^0*1.011*2^2
        s=0 M=1.011 E=2
        存入内存中: s=0 M=011 E=2+127

        存入内存中的二进制序列:
        0 10000001 01100000000000000000000
        s   E(129)       M(011,补齐23位)

        转换成16进制: 40 b0 00 00
    */

    // 浮点数存储的例子
    int n = 9;                   // 4byte
    float *pFloat = (float *)&n; // 强制类型转换,转换的是类型, n的值并没有改变
    // float也是4个字节, 它以浮点数的视角去看n的4个字节
    printf("n的值为: %d\n", n);             // 9 (未改变n的值)
    printf("*pFloat的值为: %f\n", *pFloat); // 0.000000 : 以浮点数的形式取出来
    *pFloat = 9.0;
    printf("num的值为: %d\n", n);          // 1091567616
    printf("pFloat的值为: %f\n", *pFloat); // 9.000000
    /*
    n = 9
        00000000 00000000 00000000 00001001
    以浮点数的形式取出来
        0 00000000 00000000000000000001001
        s   E           M
    E为全零, 取出来的时候:
        0.00000000000000000001001 * 2^(-126)
    所以结果为: 0.000000

    *pFloat = 9.0;
    1001.0
    1.001*2^3
    E=3
    该float数存到内存中为:
        0 100000010 00100000000000000000000

    */

    return 0;
}
