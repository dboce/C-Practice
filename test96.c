#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
#include <string.h>
/// 数据的存储1
/*
1. 数据类型详细介绍
2. 整型在内存中的存储: 原码\反码\补码
3. 大小端字节序介绍和判断
4. 浮点型在内存中的存储解析
*/

int main(int argc, char const *argv[])
{
    int i = 0;
    int arr[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    printf("%p\n", &i);      // 打印i的地址
    printf("%p\n", &arr[9]); // 打印arr[9]的地址
    /*结论:
        Debug情况下:
            i的地址大于arr[9]的地址
        Release情况下:
            i的地址小于arr[9]的地址
        说明Release情况下, 做了优化
    */
    for (i = 0; i <= 12; i++)
    {
        arr[i] = 0;
        printf("hehe\n");
    }
    /*不同调试环境下的打印:
    Debug下: 死循环
        i和arr是局部的变量
        因为局部变量是放在栈区上的, 栈区的使用习惯是: 先使用高地址, 再使用低地址.
        而数组随着下标的增长, 地址是由低到高变化的.
        数组越界导致了死循环: 此时可能arr[12]就是i,把i赋值给0, 导致一直循环下去
    Release下: 没有出现死循环
        Release版本是做优化的
    */

    /*数据类型介绍
    类型的意义:
     1.使用这个类型开辟内存空间的大小(大小决定了使用范围).
     2.如何看待内存空间的视角.
     类型的基本归类:
         整型家族:
             char
                 unsigned char
                 signed char
             short
                 unsigned short[int]
                 signed short[int]
             int
                 unsigned int
                 signed int
             long
                 unsigned long [int]
                 signed long [int]
             为什么char也叫整型呢? 因为字符类型底层存储的时候存的是这个字符的ASSIC码值,ASSIC值也是整数,所以char归属整形.
         浮点型家族:
             float
             double
         构造类型:
             数组类型
             结构体类型 struct
             枚举类型 enum
             联合类型 union
         指针类型:
             int *pi;
             char *pc;
             float* pf;
             void* pv;
         空类型:
             void表示空类型(无类型)
             通常应用于函数的返回类型\函数的参数\指针类型.
                 函数返回类型 void test();
                 函数参数 void test(void);
                 指针 void* p;
    */

    int a = -10;
    /*数据在内存中以二进制的形式存储
    对于整数来说:
        整数在内存中存储的二进制有3种表示形式: 原码\反码\补码
            正整数: 原码\反码\补码相同
            负整数: 原码\反码\补码要进行计算的
                -10
                    原码: 10000000 00000000 00000000 00001010   按照数据的数值直接写出的二进制序列就是原码
                    反码: 11111111 11111111 11111111 11110101  原码的符号位不变, 其他位按位取反, 得到的就是反码
                    补码: 11111111 11111111 11111111 11110110   反码+1, 得到的就是补码
                    4个二进制数来表示1个十六进制数
                    ff ff ff f6
                    所以: 整数在内存中存储的是它的二进制补码
                为什么内存中不存原码, 存补码呢?
                    在计算机系统中, 数值一律用补码来表示和存储.原因在于, 使用补码, 可以将符号位和数值域统一处理;
                    同时,加法和减法也可以统一处理(CPU只有加法器)此外, 补码与原码相互转换, 其运算过程相同, 不需要额外的硬件电路.

                    比如执行示例: 1-1;
                    cup是没有减法器的, 它只能做加法器模拟, 就变成了 1 + (-1);
                        1的原码:  00000000000000000000000000000001
                        -1的原码: 10000000000000000000000000000001
                        如果用原码相加计算, 结果变成了-2: 10000000000000000000000000000010
                        1的补码:  00000000 00000000 00000000 00000001
                        -1的补码: 11111111 11111111 11111111 11111111
                        补码相加计算: 1 00000000 00000000 00000000 00000000
                        多了一位, 放不下直接丢掉最高位, 得到结果0: 00000000 00000000 00000000 00000000


        符号位: (二进制数的最高位)
            负数为1, 正数为0
    */

    /*
     大端字节序:
         把数据的地位字节序的内容存放在高地址处, 高位字节序的内容存放在低地址处
     小端字节序:
         把数据的地位字节序的内容存放在低地址处, 高位字节序的内容存放在高地址处
    */
    int a = 0x11223344;
    // 通过调试,查看内存: 发现编辑器是: 小端存储
    /*大小端介绍:
    大端(存储)模式, 是指数据的低位保存在内存的高地址中, 而数据的高位, 保存在内存的低地址中;
    小端(存储)模式, 是指数据的低位保存在内存的低地址中, 而数据的高位, 保存在内存的高地址中.

    为什么有大端和小端:
        因为在计算机系统中, 我们是以字节为单位的, 每个地址单位都对应着一个字节, 一个字节为8bit.
        但是在C语言中除了8bit的char之外, 还有16bit的short型, 32bit的long型(要看具体的编译器).
        另外,对于位数大于8的处理器, 例如16位或者32位的处理器, 由于寄存器宽度大于一个字节,
        那么必然存在着一个如何将多个字节安排的问题. 因此就导致了大端存储模式和小端存储模式.
    */

    return 0;
}
